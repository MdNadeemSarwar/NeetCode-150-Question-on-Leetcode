Tumhe ek string s di gayi hai, aur tumhe saare possible ways return karne hain jisme: / Tum string ko substrings me todoge / Har ek substring palindrome hona chahiye
Possible partitions: "a" | "a" | "b" / sab palindromes âœ… "aa" | "b" / "aa" palindrome âœ…, "b" palindrome âœ…
Yeh ek backtracking problem hai, kyunki: Tumhe saare possible ways explore karne padenge / Har position pe tum decide karte ho: / Yaha cut karo / Ya thoda aur aage jao

ğŸ’¡ Approach:
Start index = 0
Har possible end index ke liye check karo ki substring palindrome hai ya nahi
Agar palindrome hai â†’ usko current path me daalo â†’ aage ke liye recursive call
Jab end of string aa jaaye â†’ current path ko result me daal do

Brute Force soch
Har jagah cut lagao (har index pe decision)
Har substring palindrome hai ya nahi check karo
Isme kaafi extra checks honge, lekin backtracking naturally eliminate karega jo palindrome nahi hain

Step 1: Start from index 0
Try "a" â†’ palindrome âœ… â†’ path = ["a"] â†’ move to index 1
Try "a" (index 1) â†’ palindrome âœ… â†’ path = ["a","a"] â†’ move to index 2
Try "b" (index 2) â†’ palindrome âœ… â†’ path = ["a","a","b"] â†’ end reached â†’ save path
Try "ab" â†’ not palindrome âŒ â†’ skip
Try "aa" (index 0 to 1) â†’ palindrome âœ… â†’ path = ["aa"] â†’ move to index 2
Try "b" â†’ palindrome âœ… â†’ path = ["aa","b"] â†’ end reached â†’ save path
Try "aab" â†’ not palindrome âŒ
âœ… Result: [["a","a","b"], ["aa","b"]]

TCâ‰ˆO(nâ‹…2)
SC= O(n)

class Solution {
public:
    vector<string>temp;
    vector<vector<string>>ans;
    bool ispalindrome(string &s, int left, int right){
        while(left < right){
            if(s[left] != s[right]){
                return false;
            }
            left++;
            right--;
        }
        return true;
    }

    void solve(int start, string &s){
        if(start == s.size()){
            ans.push_back(temp);
            return;
        }

        for(int i = start; i<s.size(); i++){
            if(ispalindrome(s, start, i)){
                temp.push_back(s.substr(start, i - start + 1));
                solve(i+1, s);
                temp.pop_back();
            }
        }
    }
    vector<vector<string>> partition(string s) {
        solve(0, s);
        return ans;
    }
};
