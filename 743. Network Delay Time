❓ Question
Aapko ek directed weighted graph diya hai jisme:
n nodes (1 to n)
times[i] = (u, v, w) matlab node u → v with travel time w
Ek starting node k diya hai.
Aapko batana hai ki signal ko k se shuru hone ke baad sabhi nodes tak pahunchne me maximum kitna time lagta hai.
Agar koi node reachable hi nahi hai, return -1.

🔑 Intuition

Ye problem Single Source Shortest Path ka hai → matlab ek source se sabhi nodes tak minimum distance nikalna hai.
👉 Iske liye hum Dijkstra’s Algorithm (Priority Queue) use karenge.

⚙️ Approach
Graph ko adjacency list me banao: u → [(v, w)]
Min-heap (priority queue) use karo → (time, node).
Distance array rakho → har node tak pahunchne ka min time.
Jab ek node PQ se nikle, uske neighbours ko relax karo.
Last me agar sabhi reachable hai to max distance return karo, warna -1.

✅ Dry Run (Example)
Input: times = [[2,1,1],[2,3,1],[3,4,1]]
n = 4, k = 2

Graph:
2 → 1 (1)
2 → 3 (1)
3 → 4 (1)

Start = 2
PQ = [(0,2)]
Dist[2]=0

Process 2 → neighbours:
(1,1), (3,1) → PQ = [(1,1),(1,3)]

Pop (1,1) → neighbour none.
Pop (1,3) → neighbour (4,2) → PQ = [(2,4)]
Pop (2,4) → done.

Distances:
1:1, 2:0, 3:1, 4:2 → Max = 2
Answer = 2

🔑 Summary of Flow
Graph banaya adjacency list me.
Min-heap PQ banayi jisme (time, node) rakha jata hai.
Start node ka distance 0 set kiya.
Har step me PQ se sabse chhota distance wala node nikaala.
Uske neighbours ko update kiya agar naya distance chhota mila.
End me sabse max distance return kiya. Agar koi node nahi mila to -1.

Final TC: O((V + E) log V)
Final SC: O(V + E)

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        
        // 1. Graph ko adjacency list me convert karna (u -> list of (v,w))
        unordered_map<int, vector<pair<int, int>>> adj;
        for(auto &vec : times) {
            
            int u = vec[0];   // source node
            int v = vec[1];   // destination node
            int w = vec[2];   // weight (time lagne wala)

            // directed edge store karte hai
            adj[u].push_back({v, w});
        }
        
        // 2. Min-heap (priority_queue) banate hai for Dijkstra
        //    By default priority_queue max-heap hota hai, 
        //    lekin humko min-heap chahiye -> isliye greater<> use karte hain.
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;

        // 3. Distance array banate hai (1-indexed graph h)
        //    initially sabhi nodes ka distance = ∞ (INT_MAX)
        vector<int> result(n+1, INT_MAX);

        // 4. Start node ka distance = 0
        result[k] = 0;

        // PQ me dalte hain start node (0 distance, node=k)
        pq.push({0, k});

        // 5. Dijkstra Algorithm
        while(!pq.empty()) {

            int d  = pq.top().first;   // abhi tak ka distance
            int node = pq.top().second; // current node
            pq.pop();

            // Node ke neighbours traverse karte hain
            for(auto &vec : adj[node]) {
                int adjNode = vec.first;   // neighbour node
                int dist    = vec.second;  // edge weight (time)

                // Agar current path chhota hai → update distance
                if(d + dist < result[adjNode]) {
                    result[adjNode] = d + dist;    // naya distance set karo
                    pq.push({d+dist, adjNode});    // PQ me push karo
                }
            }
        }
        
        // 6. Finally, answer = sabse door node tak signal ka time
        int ans = INT_MIN;
        for(int i = 1; i <= n; i++)
            ans = max(ans, result[i]);
        
        // Agar koi node unreachable hai (distance = INF),
        // to -1 return karna hai
        return ans == INT_MAX ? -1 : ans;
    }
};
