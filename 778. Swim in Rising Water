ðŸ”¹ Problem Samajhna
Tumhare paas n x n grid hai, jisme har cell ki elevation grid[i][j] hai.
Time t par, water level = t â†’ matlab aaj tak jo cells submerged ho sakte hain unka height <= t.
Tum (0,0) se start kar rahe ho aur goal hai (n-1,n-1).
Tum 4 directions me move kar sakte ho, par current time t se upar wale cells swim nahi kar sakte.
Tumhe minimum time t find karna hai jisme tum reach kar sako bottom-right corner.
Example 1:
grid = [[0,2],
        [1,3]]

t = 0 â†’ only cell (0,0) reachable â†’ cannot move
t = 1 â†’ (1,0) reachable â†’ still cannot reach (1,1)
t = 2 â†’ (0,1) reachable â†’ still cannot reach (1,1)
t = 3 â†’ (1,1) reachable â†’ minimum time = 3

ðŸ”¹ Intuition / Approach
Ye problem Minimum Maximum Path problem ke category me aata hai.
Hum chahte hain minimum time t jisme path exist kare.
Key insight:
Agar tum kisi path ke liye time t fix kar do, tum check kar sakte ho kya path exist karta hai ya nahi.
â†’ matlab Binary Search + BFS/DFS apply kar sakte ho.

Approach 1: Binary Search + BFS
left = grid[0][0] (minimum starting point)
right = n*n-1 (maximum possible elevation)
While left < right:
mid = (left+right)/2
Check if path exists at time = mid (BFS/DFS)
Agar yes â†’ right = mid
Agar no â†’ left = mid + 1
Return left
Check Path (BFS/DFS)
Start from (0,0)
Move to 4 directions if grid[nx][ny] <= t
Agar (n-1,n-1) reachable â†’ return true

Approach 2: Priority Queue (Dijkstra-like)
Isko Dijkstra / Minimum Heap approach bhi solve karta hai efficiently.
Idea: Always move to the next minimum elevation reachable cell.
Heap store karta hai (elevation, x, y)
Max elevation along the path track karo â†’ wo minimum time hoga

ðŸ”¹ Intuition Behind This Code
Binary Search on Time t
Kyunki minimum t chahiye jisme path exist kare, binary search use karna efficient hai.
DFS (reachableornot)
For a fixed t, check karte hain kya (0,0) se (n-1,n-1) tak path exist karta hai.
Move only to cells where elevation <= t and not visited.
Visited matrix
Avoid infinite loops during DFS.
Condition grid[i][j] <= T && grid[ii][jj] <= T
Ensure swimming only allowed if both current and next cell submerged at time T.

ðŸ”¹ Complexity
Time Complexity: O(n^2 log n)
Binary search log(n^2)
Each check DFS worst case visits n^2 cell
Space Complexity: O(n^2)
For visited matrix

Approach 1 BS
class Solution {
public:
    // 4 directions: right, left, down, up
    int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    int swimInWater(vector<vector<int>>& grid) {
        int n = grid.size(); // size of the grid

        int low = 0;         // minimum possible time
        int high = n*n - 1;  // maximum possible time (max elevation in grid)

        // Binary search over time t
        while(low < high){
            int mid = low + (high - low)/2; // mid time

            // visited matrix to track which cells are visited during DFS
            vector<vector<int>> visited(n, vector<int>(n, 0));

            // check if (n-1,n-1) is reachable at time = mid
            if(reachableornot(mid, grid, n, 0, 0, visited)){
                high = mid; // if reachable, try smaller time
            }
            else{
                low = mid + 1; // if not reachable, increase time
            }
        }

        return low; // minimum time when destination is reachable
    }

    // DFS function to check if bottom-right corner is reachable at time T
    int reachableornot(int T, vector<vector<int>>& grid, int N, int i, int j, vector<vector<int>> &visited){

        if(i == N-1 && j == N-1){
            return true; // reached destination
        }

        visited[i][j] = true; // mark current cell visited

        // explore all 4 directions
        for(auto dir : dirs){
            int ii = i + dir[0]; // next row
            int jj = j + dir[1]; // next col

            // check bounds, not visited, and elevation <= T for both current and next cell
            if(ii >= 0 && ii < N && jj >= 0 && jj < N && !visited[ii][jj] 
               && grid[i][j] <= T && grid[ii][jj] <= T){
                
                // recursive DFS call
                if(reachableornot(T, grid, N, ii, jj, visited)){
                    return true; // if path found, return true
                }
            }
        }

        return false; // if no path found from this cell
    }
};
--------------------------------------------------------------------------------------------------------------------------------------------------------
ðŸ”¹ Complexity Analysis
Time: O(n^2 log n) â†’ heap me push/pop operations for n^2 cells
Space: O(n^2) â†’ visited + heap

 int n = grid.size();  // Grid ka size n x n

        // 4 directions ke liye trick: right, down, left, up
        // dirs[d] & dirs[d+1] se coordinate calculate karenge
        vector<int> dirs = {-1, 0, 1, 0, -1};

        // visited matrix to avoid revisiting the same cell
        vector<vector<bool>> visited(n, vector<bool>(n, false));

        // Min-heap priority queue: store tuple {elevation, x, y}
        // smallest elevation first
        priority_queue<tuple<int,int,int>, vector<tuple<int,int,int>>, greater<tuple<int,int,int>>> pq;

        // Start from top-left corner (0,0) with its elevation
        pq.push({grid[0][0], 0, 0});
        visited[0][0] = true; // mark start cell as visited

        int res = 0; // maximum elevation along the path so far

        while(!pq.empty()) {
            auto [h, x, y] = pq.top(); pq.pop(); // pop cell with minimum elevation
            res = max(res, h); // update result: max elevation seen along path

            // if destination reached, return result
            if(x == n-1 && y == n-1) return res;

            // explore all 4 directions
            for(int d=0; d<4; d++) {
                int nx = x + dirs[d];     // next row
                int ny = y + dirs[d+1];   // next column

                // check bounds and if not visited
                if(nx >= 0 && nx < n && ny >= 0 && ny < n && !visited[nx][ny]) {
                    visited[nx][ny] = true;               // mark as visited
                    pq.push({grid[nx][ny], nx, ny});     // push next cell into heap
                }
            }
        }

        return res; // normally this line not reached
