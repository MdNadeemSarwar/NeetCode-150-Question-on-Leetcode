ðŸ”¹ Problem Samajhna
Tumhe ek string s aur ek number k diya hai.
Tum maximum k characters change karke sabse bada substring banana chahte ho jisme sirf ek hi character repeat ho raha ho.
ðŸ‘‰ Example: s = "ABAB", k = 2
Tum A ko B me ya B ko A me change kar sakte ho.
Agar dono A ko B bana do â†’ "BBBB" ban gaya â†’ length = 4 âœ…

ðŸ”¹ Key Intuition
Hume ek substring lena hai aur dekhna hai kya at most k replacement karke usme sabhi characters ek hi ban sakte hain. Kaise check karenge?
Ek substring me sabse zyada repeat hone wala character fix kar lo.
Baaki characters ko usme convert karna hoga.
Required replacements = window_size - max_freq_in_window.
Agar ye â‰¤ k hai â†’ window valid hai.

ðŸ”¹ Approach (Sliding Window)
Ek sliding window (l..r) maintain karo.
Har step me right character include karo aur uska frequency map update karo.
Current window ka max_freq track karo.
Agar (window_size - max_freq) > k â†’ window invalid â†’ left pointer ko slide karo.
Har step pe max window length update kar lo.

ðŸ”¹ Dry Run
s = "AABABBA", k = 1
Start: l=0, r=0 â†’ window="A" â†’ max_freq=1 â†’ window_size=1 â†’ valid â†’ ans=1
r=1 â†’ window="AA" â†’ max_freq=2 â†’ window_size=2 â†’ valid â†’ ans=2
r=2 â†’ window="AAB" â†’ max_freq=2 â†’ window_size=3 â†’ replacements=1 â†’ valid â†’ ans=3
r=3 â†’ window="AABA" â†’ max_freq=3 â†’ window_size=4 â†’ replacements=1 â†’ valid â†’ ans=4
r=4 â†’ window="AABAB" â†’ max_freq=3 â†’ window_size=5 â†’ replacements=2 â†’ invalid â†’ shift l=1
Now window="ABAB" â†’ max_freq=2 â†’ window_size=4 â†’ replacements=2 â†’ invalid â†’ shift l=2
Window="BAB" â†’ max_freq=2 â†’ window_size=3 â†’ valid â†’ ans=4 (still max)
Continue â†’ finally ans=4 âœ…

s[right] - 'A' kyu?
String me uppercase letters A..Z hote hain.
ASCII me: 'A' ka index 65 hota hai
'C' - 'A' = 67 - 65 = 2
Isse hum letter ko 0..25 index me map kar lete hain, aur freq[26] array se frequency count kar lete hain.
Example:
'A' - 'A' = 0
'B' - 'A' = 1
'Z' - 'A' = 25
             Q/A
1) right - left + 1 = window size kyun?
Hamari sliding window left se right tak inclusive hoti hai.
Length (size) ka formula:
agar left = 0, right = 0 â†’ size = 1
agar left = 0, right = 3 â†’ indices 0,1,2,3 = 4 chars
General formula: right - left + 1

2) replacements = window_size - maxCount kyun?
Hume window ke saare characters ko SAME banana hai. Sabse sasta tareeka kya?
ðŸ‘‰ Jo character already sabse zyada baar aata hai usko target letter maan lo (kyunki usko change karna sabse kam padega).
maxCount = window me most frequent character ki count
Baaki sab ko usi character me replace karna hoga
Required replacements = total chars âˆ’ already-correct chars
â‡’ (right - left + 1) - maxCount
Example: Window "AABA": counts â†’ A=3, B=1
window_size = 4
maxCount = 3 (A)
replacements = 4 âˆ’ 3 = 1 (sirf ek B ko A karna hai)

3) Jab required > k ho to left++ kyun?
k = allowed replacements (limit)
Agar required > k, matlab ye window zyada badi ho gayi: isko chhota karo.
Window chhoti kaise hogi? Left ko aage badhao (left++), aur jo char bahar gaya uski frequency ko -1 karo:
freq[s[left] - 'A']--;
left++;
Hum left ko tab tak badhate hain jab tak required â‰¤ k ho jaaye. Tab window phir se valid ho jaati hai.

Time: O(N) (har char window me ek baar aata + ek baar nikalta)
Space: O(26) ~ O(1)

class Solution {
public:
    int characterReplacement(string s, int k) {
       vector<int> freq(26, 0);   // 26 uppercase letters ke counts
        int left = 0;              // window ka left pointer
        int maxCount = 0;          // window me sabse zyada baar aane wale char ki count
        int ans = 0;               // best (max) window length

        for (int right = 0; right < (int)s.size(); right++) {
            // 1) right char ko include karo aur uska freq badhao
            freq[s[right] - 'A']++;

            // 2) maxCount update karo (abhi wali window me max freq)

            maxCount = max(maxCount, freq[s[right] - 'A']);

            // 3) check: kitne replacements chahiye is window ko single-letter banane me?
            // replacements = window_size - maxCount  ye window size nekal raha hai right - left + 1
            // agar required > k => window bada hai, left ko aage badhao jab tak valid na ho jaye
            while ((right - left + 1) - maxCount > k) {
        // yaha maxcount yani manlo A 3 bar aaya hai windowsize = 4 = 4 - 3 = 1 yane bas 1 digit ko change karke B karna hai 
                freq[s[left] - 'A']--;
                left++;
            }

            // 4) yahan tak aa gaye matlab window valid hai; answer update karo
            ans = max(ans, right - left + 1);
        }
        return ans;   
    }
};
