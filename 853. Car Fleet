ðŸ”¹ Question Statement (Simple Words me)
Aapke paas n cars hain jo target position ki taraf move kar rahi hain.
Har car ka starting position aur speed diya gaya hai.
Rule yeh hai ki ek car kabhi bhi aage wali car ko overtake nahi kar sakti.
Agar koi car piche se aake aage wali car ko catch up kar leti hai (same position pe milti hai), toh wo dono fleet bana leti hain aur uske baad ek group me same speed se chalti hain.
Aapko batana hai ki target tak kitne fleets pahunchengi.

ðŸ”¹ Intuition / Approach
ðŸ”¹ Approach:

Har car ke liye time = (target - position) / speed nikal lo â†’ kitne time me target pahunchti hai.
Cars ko unke position ke basis pe sort karo (descending, sabse aage wali pehle).
Ek loop chalake check karo:
Agar peeche wali car ka time <= current fleet time, matlab wo us fleet ko catch kar legi â†’ new fleet nahi banega.
Agar time > current fleet time, to ye ek new fleet banayegi.

ðŸ”¹ Example Dry Run
target = 12
position = [10, 8, 0, 5, 3]
speed    = [2,  4, 1, 1, 3]

Time calculate:
pos 10 â†’ (12-10)/2 = 1
pos 8 â†’ (12-8)/4 = 1
pos 0 â†’ (12-0)/1 = 12
pos 5 â†’ (12-5)/1 = 7
pos 3 â†’ (12-3)/3 = 3
Cars = {(10,1), (8,1), (0,12), (5,7), (3,3)}

Sort by position (desc):
{(10,1), (8,1), (5,7), (3,3), (0,12)}

Traverse:
Car at 10 â†’ time=1 > 0 â†’ new fleet (fleet=1, maxTime=1)
Car at 8 â†’ time=1 â‰¤ maxTime(1) â†’ same fleet
Car at 5 â†’ time=7 > maxTime(1) â†’ new fleet (fleet=2, maxTime=7)
Car at 3 â†’ time=3 â‰¤ maxTime(7) â†’ same fleet
Car at 0 â†’ time=12 > maxTime(7) â†’ new fleet (fleet=3, maxTime=12)
âœ… Answer = 3 fleets

Time: O(n log n) (sorting)
Space: O(n) to store pairs (or O(1) extra if you sort indices in place)

class Solution {
public:
    int carFleet(int target, vector<int>& position, vector<int>& speed) {
          int n = position.size();
        vector<pair<int, double>> cars; // {position, time}

        // Step 1: Calculate time for each car
        for (int i = 0; i < n; i++) {
            double time = (double)(target - position[i]) / speed[i];
            cars.push_back({position[i], time});
        }

        // Step 2: Sort cars by position descending
        sort(cars.rbegin(), cars.rend());

        // Step 3: Traverse and count fleets
        int fleets = 0;
        double maxTime = 0.0;

        for (auto& car : cars) {
            double time = car.second;
            if (time > maxTime) {  
                fleets++;       // new fleet ban rahi hai
                maxTime = time; // update fleet ka time
            }
        }

        return fleets;
    }
};
