ðŸ“Œ Question Understanding
Aapko ek class banani hai DetectSquares jisme teen main kaam karne hain:
add(point)
â†’ ek point (x, y) add karna hai data structure me. Multiple same points ho sakte hain, unko bhi count karna hai.
count(point)
â†’ ek point (x, y) diya hoga. Aapko dekhna hai kitne axis-aligned squares ban sakte hain jisme ye (x, y) ek corner ho.
Square axis-aligned matlab uske sides X-axis aur Y-axis ke parallel hone chahiye.
ðŸ‘‰ Example: add(3,10), add(11,2), add(3,2)
count(11,10) â†’ 1 milega kyunki ek square exist karta hai with points:
(11,10) â† query point
(11,2)
(3,10)
(3,2)

ðŸ“Œ Approach ko samajhte hain
Aapko 2 cheezon ka dhyaan rakhna hoga:
Point storage:
Jab bhi point add karenge, hume usko ek counter me store karna hai.
Kyonki ek hi point multiple times add ho sakta hai.
Matlab ek dictionary/hashtable banaenge cnt[x][y] = count.
Square banane ka logic (count method):
Query point fix hoga, maan lo (qx, qy).
Ab square banane ke liye:
Hume same row (same y) wale x points dhoondhne honge.
Ya phir same column (same x) wale y points dhoondhne honge.
Square banane ke liye:
Side length = |qx - x| = |qy - y|
Hume dekhna padega ki diagonally opposite points exist karte hain ya nahi.

ðŸ“Œ Step by Step Dry Run
Example:
add(3,10)
add(11,2)
add(3,2)
count(11,10)

Step 1: Storage
cnt[3][10] = 1
cnt[11][2] = 1
cnt[3][2] = 1

Step 2: Query â†’ count(11,10)
Query point = (11,10)
Check all points with same x = 11 â†’ (11,2)
Side = |qy - y| = |10 - 2| = 8
Matlab possible other x = 11 Â± 8 â†’ x = 3 or x = 19
Case 1: x = 3

Check points:
(3,10) â†’ exist? âœ… cnt[3][10] = 1
(3,2) â†’ exist? âœ… cnt[3][2] = 1
Square ban gaya â†’ count = 1
Case 2: x = 19
Check points:

(19,10) â†’ exist? âŒ
(19,2) â†’ exist? âŒ

No square. ðŸ‘‰ Final Answer = 1

ðŸ“Œ Why code uses nested map/dict?
Because we need fast access â†’ cnt[x][y]
Agar multiple times add hua, toh count bhi store ho sake.
Square count karte waqt multiplication hota hai (cnt[point1] * cnt[point2]) kyunki ek hi coordinate multiple times add ho sakta hai.

Overall TC:
Add â†’ O(1)
Count â†’ O(N)
SC: O(N)

class DetectSquares {
public:
    // map of maps -> cnt[x][y] = frequency of point (x,y)
    unordered_map<int, unordered_map<int,int>> cnt;
    
    // add new point
    void add(vector<int> point) {
        int x = point[0], y = point[1];
        cnt[x][y]++;  // increase frequency
    }

    // count number of squares using query point
    int count(vector<int> point) {
        int x = point[0], y = point[1];
        int res = 0;
        
        // iterate over all points with same x (same column)
        for (auto& [colY, freq] : cnt[x]) {
            if (colY == y) continue; // skip same point
            
            int side = colY - y; // possible side length
            
            // check 2 horizontal possibilities (left & right)
            // 1. right side: (x+side, y), (x+side, colY)
            int x2 = x + side;
            if (cnt.count(x2)) {
                res += freq * cnt[x2][y] * cnt[x2][colY];
            }

            // 2. left side: (x-side, y), (x-side, colY)
            x2 = x - side;
            if (cnt.count(x2)) {
                res += freq * cnt[x2][y] * cnt[x2][colY];
            }
        }
        return res;
    }
};
