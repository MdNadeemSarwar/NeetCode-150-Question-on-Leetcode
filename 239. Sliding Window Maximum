Tumhe ek array diya gaya hai aur ek window size k.
Har step me ek window slide hoti hai aur hame us window ka maximum element nikalna hai.
Example: nums = [1,3,-1,-3,5,3,6,7], k=3

Windows banenge:
[1,3,-1] â†’ max = 3
[3,-1,-3] â†’ max = 3
[-1,-3,5] â†’ max = 5
[-3,5,3] â†’ max = 5
[5,3,6] â†’ max = 6
[3,6,7] â†’ max = 7
Output â†’ [3,3,5,5,6,7] âœ…

ðŸ”¹ Brute Force Approach (O(n*k))
Har window ka maximum nikalne ke liye traverse karna.
Bahut slow (O(n*k)) ho jata hai jab array bada ho.

ðŸ”¹ Optimized Approach (O(n)) â†’ Using Deque
Why Deque?
Kyunki hame har window me max element ko efficiently track karna hai.
Aur window slide hone par purane elements ko remove bhi karna hai.
Queue sirf FIFO deta hai, stack sirf LIFO deta hai.
Lekin deque (double ended queue) hame dono side se add/remove karne ka option deta hai. Yeh sliding window ke liye perfect hai. âœ…

ðŸ”¹ Core Intuition of Deque in this Question
Deque me indexes store karenge, values nahi.
Kyunki hame pata hona chahiye ki element abhi current window me hai ya bahar nikal gaya.
Deque ko decreasing order me maintain karenge (values ke hisaab se).
Matlab front me hamesha current window ka maximum hoga.
Jab bhi ek naya element aata hai, hum deque ke pichhe se chhote elements hata dete hain, kyunki wo kabhi future max nahi banenge.
Window ke bahar ke elements ko remove karna.
Agar deque ka front index current window ke bahar chala gaya, to use pop kar do.

ðŸ”¹ Step by Step Dry Run (nums = [1,3,-1,-3,5,3,6,7], k=3)

Deque = indexes (values bracket me)
i=0 â†’ num=1
Deque empty â†’ push(0) â†’ Deque = [0 (1)]

i=1 â†’ num=3
3 > 1 â†’ pop_back(0)
push(1) â†’ Deque = [1 (3)]

i=2 â†’ num=-1
-1 chhota hai â†’ push(2)
Deque = [1 (3), 2 (-1)]
Window size = 3 â†’ max = nums[1] = 3 âœ…

i=3 â†’ num=-3
Window [1..3]
Deque front(1) = index1 â†’ still inside window â†’ keep
-3 chhota hai â†’ push(3)
Deque = [1 (3), 2 (-1), 3 (-3)]
Max = nums[1] = 3 âœ…

i=4 â†’ num=5
5 > -3 â†’ pop_back(3)
5 > -1 â†’ pop_back(2)
5 > 3 â†’ pop_back(1)
Push(4) â†’ Deque = [4 (5)]
Max = nums[4] = 5 âœ…

i=5 â†’ num=3
3 < 5 â†’ push(5)
Deque = [4 (5), 5 (3)]
Max = nums[4] = 5 âœ…

i=6 â†’ num=6
6 > 3 â†’ pop_back(5)
6 > 5 â†’ pop_back(4)
Push(6) â†’ Deque = [6 (6)]
Max = nums[6] = 6 âœ…

i=7 â†’ num=7
7 > 6 â†’ pop_back(6)
Push(7) â†’ Deque = [7 (7)]
Max = nums[7] = 7 âœ…
ðŸ‘‰ Output = [3,3,5,5,6,7]

ðŸ”¹ Conclusion (Why Deque is Needed?)
Kyunki hame ek hi data structure chahiye jo:
Max ko front me rakhe (sorted decreasing order maintain karke).
Purane elements ko nikal sake jab wo window ke bahar ho jaye.
Future ke liye useless elements ko hata sake (jo naya element bada hai unse).
âš¡Isliye deque hi best choice hai sliding window maximum ke liye.

TC = O(n)
SC = O(k) (excluding output array),
SC = O(n + k) (including output).

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq; // indices store karne ke liye deque (direct values nahi, index store hoga)
        vector<int> ans; // final answer store karega (har window ka max)

        // poora array traverse karenge
        for (int i=0; i<nums.size(); i++) {
            // 1. remove out-of-window elements
            // agar dq ka front (sabse pehle wala index) current window se bahar ho gaya (i-k) to use hatana padega

            if (!dq.empty() && dq.front() <= i-k) {
                dq.pop_front(); 
            }
            // 2. maintain decreasing order in deque
            // agar deque ke last wale element ki value nums[i] se chhoti hai
            // to uska koi kaam nahi (future me bada element mil gaya)
            // isiliye usse hata dete hain
            while (!dq.empty() && nums[dq.back()] < nums[i]) {
                dq.pop_back();
            }
            // ab current index ko deque me daal dete hain
            dq.push_back(i);
            // 3. record answer when window is ready
            // jab tak window ka size >= k nahi hota, tab tak max store nahi karenge
            // jab i >= k-1 ho jaata hai, tab ek valid window ban jaati hai
            // uska max hamesha dq.front() pe hoga
            if (i >= k-1) {
                ans.push_back(nums[dq.front()]);
            }
        }
        return ans; // sabhi windows ke max return karte hain
    }
};
