ðŸ“Œ Question Samajhna
Ek aisa data structure design karna hai jo do operations support kare:
addWord(word) â†’ ek word ko store kar do.
search(word) â†’ check karo ki word present hai ya nahi.
Special case: word ke andar '.' aa sakta hai, jo kisi bhi ek character ko represent karega.

ðŸŽ¯ Intuition
Agar simple array/vector me store karte â†’ search ke time har word compare karna padta (slow).
Trie (Prefix Tree) use karenge:
Trie har character ko ek node ke form me store karega.
isEndOfWord flag rakha jayega jo mark karega ki koi word yaha khatam hota hai.
'.' ke liye â†’ ek character nahi, sab possible children explore karna hoga (DFS recursion use karke).

ðŸ› ï¸ Approach
TrieNode structure banate hai:
children[26] â†’ har letter ka pointer.
isEndOfWord â†’ true agar word yaha end hota hai.
addWord(word):
Root se start karo.
Har character ke liye child check karo. Agar child missing ho to naya node banao.
Last character par isEndOfWord = true set kar do.
search(word):
Har character traverse karo.
Agar normal letter hai â†’ us child me move karo.
Agar '.' hai â†’ har child explore karo (recursively call searchUtil). Agar kisi me match mila â†’ return true.
Agar poora word traverse karke isEndOfWord == true hai â†’ return true, warna false.

ðŸ“– Dry Run Example Input:

addWord("bad")
addWord("dad")
addWord("mad")
search("pad") â†’ ?
search("bad") â†’ ?
search(".ad") â†’ ?
search("b..") â†’ ?

Trie ban gaya jisme bad, dad, mad store hai.
search("pad") â†’ 'p' se start hota hai, par trie me 'p' child nahi â†’ âŒ False.
search("bad") â†’ har char match mil gaya â†’ âœ… True.
search(".ad") â†’ pehle character '.' hai â†’ humne children 'b', 'd', 'm' explore kiye. Teeno me "ad" mil gaya â†’ âœ… True.
search("b..") â†’ pehle 'b' match hua, fir do '.' â†’ matlab 'a', 'd' try kiya, end me word complete mila â†’ âœ… True.

â±ï¸ Time Complexity
addWord(word) â†’ O(L), jaha L = word ka length.
search(word) â†’
Normal case: O(L).
Worst case (jab dots '.' ho) â†’ O(26^k * L), jaha k = number of dots (yahaan â‰¤ 2).
Practically fast hai.
ðŸ’¾ Space Complexity
Har node me 26 children array hai â†’ O(26 * N * L) worst case,
jaha N = number of words, L = average length.

class WordDictionary {
public:
    
    // Trie ke ek node ka structure banaya
    struct trieNode { 
        trieNode *children[26]; // har node ke 26 children (a-z ke liye)
        bool isEndOfWord;       // true agar koi word yaha end hota hai
    };
    
    // naya node banane ke liye helper function
    trieNode* getNode() {
        trieNode* newNode = new trieNode();   // ek new node allocate karte hai
        newNode->isEndOfWord = false;         // initially koi word yaha end nahi hota
        
        // saare 26 children ko NULL se initialize karte hai
        for (int i = 0; i < 26; i++) {
			newNode->children[i] = NULL;
		}
        
        return newNode;   // banaya hua node return kar diya
    }
    
    /** Initialize your data structure here. */
    trieNode* root;   // root node of Trie
    
    WordDictionary() {
        root = getNode();   // constructor ke andar root ko initialize kiya
    }
    
    // addWord function: word ko trie me insert karta hai
    void addWord(string word) {
        trieNode *crawler = root;   // root se start karte hai
        
        // har character ke liye loop
        for (int i = 0; i < word.length(); i++) { 
            int index = word[i] - 'a';  // character ka index (0-25)
            
            // agar child exist nahi karta to naya node banao
            if (!crawler->children[index]) 
                crawler->children[index] = getNode();
            
            // crawler ko us child par move kar do
            crawler = crawler->children[index]; 
        }
        
        // last character ke node par isEndOfWord = true set kar do
        crawler->isEndOfWord = true; 
    }
    
    // searchUtil function: DFS ki tarah kaam karta hai
    // yeh word ko search karta hai, aur '.' ko handle karta hai
    bool searchUtil(trieNode* root, string word) {
        trieNode *crawler = root;   // root se start karte hai
        
        // word ke har character ke liye loop
        for (int i = 0; i < word.length(); i++) { 
            char ch = word[i];   // current character
            
            // agar '.' mila
            if(ch == '.') {
                // '.' ka matlab: sab children check karna padega
                for(int j = 0; j < 26; j++) {
                    if(crawler->children[j] != NULL) {
                        // agar kisi child me baaki word match ho gaya
                        if(searchUtil(crawler->children[j], word.substr(i+1)))
                            return true; // to true return kar do
                    }
                }
                // agar koi child match nahi hua
                return false;
                
            } 
            // agar normal character hai aur child exist nahi karta
            else if (crawler->children[ch-'a'] == NULL) {
                return false; // word match nahi hua
            }
            
            // agar child exist karta hai to waha move kar jao
            crawler = crawler->children[ch-'a']; 
        }
        // agar poora word traverse ho gaya aur isEndOfWord = true hai
        return (crawler != NULL && crawler->isEndOfWord); 
    }
    
    // ye function user ke call ke liye hai
    bool search(string word) {
        return searchUtil(root, word);   // root se searchUtil ko call karte hai
    }
};
