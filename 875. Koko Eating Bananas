Ek bandar hai â€“ Koko ğŸ’.
Uske paas bananas ke piles ( à¤¢à¥‡à¤° ) rakhe hue hain.
Har pile me kuch bananas hain. Example:

piles = [3, 6, 7, 11]
Matlab:
Pehle à¤¢à¥‡à¤° me 3 bananas
Dusre à¤¢à¥‡à¤° me 6 bananas
Teesre à¤¢à¥‡à¤° me 7 bananas
Chauthe à¤¢à¥‡à¤° me 11 bananas

Koko ko sab khatam karne hain ek fixed speed k bananas per hour ke hisaab se. Aur total Koko ke paas h ghante ka time hai.

Question pooch raha hai:
ğŸ‘‰ Koko ko minimum speed (k) se khana hoga taaki wo h ghanto ke andar sab khatam kar paaye?

Important Rule
Ek pile me Koko jab start karega, wo usi pile ke bananas khayega us hour me.
Agar bananas kam hain k se, toh wo 1 ghanta hi lega (chaahe pile 3 ho aur speed 4, fir bhi 1 ghanta lagega).
Agar pile me bananas jyada hain, toh usko ceil(pile / k) hours lagenge.

Ab Example 1: piles = [3, 6, 7, 11]  h = 8

Step 1: Try k = 3
pile = 3 â†’ 1 ghanta
pile = 6 â†’ 2 ghante (3+3)
pile = 7 â†’ 3 ghante (3+3+1)
pile = 11 â†’ 4 ghante (3+3+3+2)
Total = 10 hours âŒ (limit se jyada ho gaya)

Step 2: Try k = 4
pile = 3 â†’ 1 ghanta
pile = 6 â†’ 2 ghante (4+2)
pile = 7 â†’ 2 ghante (4+3)
pile = 11 â†’ 3 ghante (4+4+3)
Total = 8 hours âœ… (perfect fit)

Step 3: Check smaller k
k=3 â†’ 10 hours (nahi possible)
k=4 â†’ 8 hours (possible)
Matlab minimum k = 4 hai. âœ”ï¸
ğŸ‘‰ Matlab Koko ko 4 bananas per hour khane ki speed rakhni padegi, tabhi wo 8 hours ke andar sab pile khatam kar paayega.

TC = O(n Ã— log(maxPile))
SC = O(1)

class Solution {
public:
    
    bool canEatAll(vector<int>& piles, int givenHour, int h) {
        int actualHour = 0;
        
        for(int &x : piles) {
            actualHour += x/givenHour;
            
            if(x%givenHour != 0)
                actualHour++;
            
        }
        
        return actualHour <= h;
    }
    
    int minEatingSpeed(vector<int>& piles, int h) {
        int n = piles.size();
        
        int l = 1, r = *max_element(begin(piles), end(piles));
        
        while(l < r) {
            int mid = l + (r-l)/2;
            
            if(canEatAll(piles, mid, h)) {
                r = mid;
            } else {
                l = mid+1;
            }
            
        }
        
        return l;
    }
};

------------------------------------------------------------------------------------------------------------------------------------------------------------

Initial values:

piles = [3, 6, 7, 11]

h = 8

l = 1

r = max(piles) = 11

Loop condition: while (l < r).

Iteration 1

l = 1, r = 11
mid = l + (r-l)/2 = 1 + (10)/2 = 6
Call canEatAll(piles, givenHour = 6, h = 8)
Compute actualHour step-by-step:
For x = 3:
x / 6 = 0 (integer division), x % 6 != 0 â†’ add 1 hour â†’ actualHour = 1
(Interpretation: pile of 3 with speed 6 takes 1 hour)

For x = 6:
6 / 6 = 1, 6 % 6 == 0 â†’ no extra â†’ actualHour = 1 + 1 = 2
(pile 6 takes 1 hour)

For x = 7:
7 / 6 = 1, 7 % 6 != 0 â†’ extra 1 â†’ actualHour = 2 + 1 + 1 = 4
(pile 7 takes 2 hours: 6 + 1)

For x = 11:
11 / 6 = 1, 11 % 6 != 0 â†’ extra 1 â†’ actualHour = 4 + 1 + 1 = 6
(pile 11 takes 2 hours: 6 + 5)

Final actualHour = 6.
Check actualHour <= h â†’ 6 <= 8 â†’ true.

So canEatAll(6) == true â†’ we can eat all with speed 6.
Action in binary search: r = mid = 6.

Iteration 2
New l = 1, r = 6
mid = 1 + (6-1)/2 = 1 + 5/2 = 3 (integer)
Call canEatAll(piles, givenHour = 3, h = 8)

Compute actualHour:

x = 3: 3/3 = 1, 3%3==0 â†’ +1 â†’ actualHour = 1
x = 6: 6/3 = 2, 6%3==0 â†’ +2 â†’ actualHour = 3
x = 7: 7/3 = 2, 7%3 != 0 â†’ + (2 + 1) â†’ actualHour = 3 + 3 = 6
(7 needs 3 hours at speed 3: 3+3+1)
x = 11: 11/3 = 3, 11%3 != 0 â†’ + (3 + 1) â†’ actualHour = 6 + 4 = 10

(11 needs 4 hours at speed 3)

Final actualHour = 10.
Check 10 <= 8 â†’ false.

So canEatAll(3) == false â†’ speed 3 not enough.
Action: l = mid + 1 = 4.

Iteration 3
Now l = 4, r = 6
mid = 4 + (6-4)/2 = 4 + 2/2 = 5
Call canEatAll(piles, givenHour = 5, h = 8)

Compute actualHour:

x = 3: 3/5 = 0, remainder -> +1 â†’ actualHour = 1 (3 takes 1 hour)
x = 6: 6/5 = 1, remainder -> +1 â†’ actualHour = 1 + 2 = 3 (6 takes 2 hours)
x = 7: 7/5 = 1, remainder -> +1 â†’ actualHour = 3 + 2 = 5 (7 takes 2 hours)
x = 11: 11/5 = 2, remainder -> +1 â†’ actualHour = 5 + 3 = 8 (11 takes 3 hours)

Final actualHour = 8.
Check 8 <= 8 â†’ true.
So canEatAll(5) == true â†’ action: r = mid = 5.

Iteration 4
l = 4, r = 5
mid = 4 + (5-4)/2 = 4 + 1/2 = 4 (integer)
Call canEatAll(piles, givenHour = 4, h = 8)

Compute actualHour:

x = 3: 3/4 = 0, remainder -> +1 â†’ actualHour = 1
x = 6: 6/4 = 1, remainder -> +1 â†’ actualHour = 1 + 2 = 3 (6 needs 2 hours: 4+2)
x = 7: 7/4 = 1, remainder -> +1 â†’ actualHour = 3 + 2 = 5 (7 needs 2 hours)
x = 11: 11/4 = 2, remainder -> +1 â†’ actualHour = 5 + 3 = 8 (11 needs 3 hours)

Final actualHour = 8.
Check 8 <= 8 â†’ true.

So canEatAll(4) == true â†’ action: r = mid = 4.
Now loop condition
Afte last step l = 4, r = 4.
while(l < r) condition fails (4 < 4 false) â†’ exit loop.
Return l â†’ return 4.
Answer = 4 â†’ exactly what we expected.
