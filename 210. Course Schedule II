ðŸ”¹ Problem ko samajhte hain:
Aapke paas numCourses courses hain (0 se numCourses-1 tak).
prerequisites diya hai: agar [a, b] diya hai â†’ iska matlab hai course a lene se pehle course b complete karna zaroori hai.
Aapko valid course order nikalna hai jisme sab prerequisites satisfy ho jaaye.
Agar cycle ho jaaye (jaise ek dusre pe depend karte rahenge endlessly) â†’ to empty array return karna hai.

ðŸ”¹ Intuition (Kya karna hai aur kaise sochna hai):
Ye problem ek Directed Graph banati hai jisme:
Nodes = courses
Edges = dependency (b â†’ a)
Example: numCourses = 4
prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Graph:
0 â†’ 1
0 â†’ 2
1 â†’ 3
2 â†’ 3
Ab hume ek aisa order chahiye jisme pehle prerequisites aaye, baad me dependent course.
ðŸ‘‰ Ye exactly Topological Sort ka case hai.

ðŸ”¹ Kaise solve karenge? (Approach)
2 Methods hai Topological Sort ke liye:
Kahnâ€™s Algorithm (BFS using Indegree)
DFS + Stack
Main tumhe Kahnâ€™s Algorithm (BFS) batata hoon kyunki ye exam/DSA interviews me jyada samajhne layak hota hai.

ðŸ”¹ Kahnâ€™s Algorithm (BFS Intuition):
Har course ka indegree nikal lo (kitne prerequisites chahiye us course ke liye).
Example: course 1 ke liye agar [1,0] hai â†’ matlab indegree[1]++ hoga.
Jis course ka indegree = 0 hai â†’ wo turant start kar sakte ho. Unko queue me daalo.
Queue se ek ek karke course nikalte jao:
Uske dependent courses ka indegree reduce kar do (kyunki prerequisite complete ho gaya).
Agar kisi ka indegree 0 ho gaya to usko bhi queue me daal do.
Jo order me courses niklenge â†’ wahi ek valid course order hoga.
Agar sab courses process ho gaye â†’ order return karo, warna [] return karo (cycle case).

ðŸ”¹ DFS + Stack Approach (Intuition)

Har course ko ek graph node maan lo.
DFS traversal se post-order me nodes ko stack me daalenge.
Matlab: pehle prerequisites visit karenge, phir course ko stack me daalenge.
Isse naturally ek valid topological order banega.
Agar DFS ke dauraan koi node recur stack me dobara dikhe â†’ iska matlab cycle hai â†’ empty array return karenge.

ðŸ”¹ DFS me 3 states track karte hain:
0 = not visited
1 = visiting (abhi DFS stack me hai)
2 = visited (completely processed ho chuka hai)
ðŸ”¹ Steps:
Graph banate hain adjacency list se.
Har node pe DFS call karo agar wo visit nahi hua hai.
DFS me:
Agar node visiting state me mil jaye â†’ cycle hai (return false).
Agar node already visited hai â†’ ignore karo.
Nahi to usko visiting mark karo aur uske neighbors pe DFS call karo.
Sab complete ho gaye â†’ node ko visited mark karke stack/order me daal do.
Agar cycle detect nahi hua â†’ stack ke reverse ko return kar do (topological order).

ðŸ”¹ Dry Run (Example 2)
numCourses = 4
prerequisites = [[1,0],[2,0],[3,1],[3,2]]

Graph:

0 â†’ [1, 2]
1 â†’ [3]
2 â†’ [3]
3 â†’ []

DFS traversal:
Start 0 â†’ goes to 1 â†’ goes to 3 â†’ 3 processed â†’ push 3
Back to 1 â†’ push 1
Back to 0 â†’ goes to 2 â†’ goes to 3 (already visited) â†’ push 2
Finally push 0
Stack (postorder): [3,1,2,0]
Reverse â†’ [0,2,1,3] âœ… valid order

Time: O(V + E)
Space: O(V + E) (graph + recursion stack + state array)

class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
         vector<vector<int>> adj(numCourses);
        for (auto &pre : prerequisites) {
            adj[pre[1]].push_back(pre[0]);
        }

        vector<int> state(numCourses, 0); // 0 = not visited, 1 = visiting, 2 = visited
        vector<int> order;
        bool hasCycle = false;

        function<void(int)> dfs = [&](int node) {
            if (hasCycle) return;

            state[node] = 1; // mark as visiting
            for (int next : adj[node]) {
                if (state[next] == 0) {
                    dfs(next);
                } else if (state[next] == 1) {
                    hasCycle = true; // cycle detected
                }
            }
            state[node] = 2; // mark as visited
            order.push_back(node); // add to order
        };

        for (int i = 0; i < numCourses; i++) {
            if (state[i] == 0) {
                dfs(i);
            }
        }

        if (hasCycle) return {};
        reverse(order.begin(), order.end());
        return order;
    }
};
